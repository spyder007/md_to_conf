{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Markdown to Confluence (md-to-conf) Documentation","text":""},{"location":"#about-the-project","title":"About The Project","text":"<p><code>md-to-conf</code> is a Python module for publishing Markdown files to Confluence.</p>"},{"location":"#built-with","title":"Built With","text":"<ul> <li>Python</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#105-2023-08-14","title":"[1.0.5] - 2023-08-14","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Change Log</li> </ul>"},{"location":"CHANGELOG/#104-2023-08-14","title":"[1.0.4] - 2023-08-14","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Documentation via mkdocs, including a documentation publish pipeline</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Added an <code>r</code> (raw) designation to Regex strings.</li> <li>Updated docstrings to Google style.</li> </ul>"},{"location":"CHANGELOG/#103-2023-08-11","title":"[1.0.3] - 2023-08-11","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Reverted Sonar suggestions to fix bug with TOC</li> </ul>"},{"location":"CHANGELOG/#102-2023-08-10","title":"[1.0.2] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Reduced complexity on some functions</li> <li>Applied Black/Flake8 formatting across files</li> </ul>"},{"location":"CHANGELOG/#101-2023-08-10","title":"[1.0.1] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Fixed PyPi packaging to properly version the published wheel</li> </ul>"},{"location":"CHANGELOG/#100-2023-08-10","title":"[1.0.0] - 2023-08-10","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Completed migration from RittmanMead/md_to_conf with packaging and PyPi publishing</li> </ul>"},{"location":"contributing/","title":"Contribution Guidelines","text":""},{"location":"contributing/#environment-configuration","title":"Environment Configuration","text":"<p>It is recommended that you use a virtual environment for development.</p>"},{"location":"contributing/#venv","title":"VENV","text":"<p>Create a new python virtualenv and activate it:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"contributing/#anaconda","title":"Anaconda","text":"<p>Installation Guide</p> <pre><code>  conda create --name md_to_conf python=3.11 --yes\n  conda activate md_to_conf\n</code></pre>"},{"location":"contributing/#requirements","title":"Requirements","text":"<p>Install the requirements for the application:</p> <pre><code>pip install -r requirements.txt\npip install -r requirements-dev.txt\n</code></pre>"},{"location":"contributing/#install-the-module","title":"Install the Module","text":"<p>Install the module in an editable mode:</p> <pre><code>pip install -e .\n</code></pre> <p>Run <code>md-to-conf -h</code> and verify that the help is displayed.</p>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are what make the open source community such an amazing place to be learn, inspire, and create. Any contributions you make are greatly appreciated.</p> <ol> <li>Fork the Project</li> <li>Create your Feature Branch (<code>git checkout -b feature/AmazingFeature</code>)</li> <li>Commit your Changes (<code>git commit -m 'Add some AmazingFeature'</code>)</li> <li>Push to the Branch (<code>git push origin feature/AmazingFeature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"contributing/#formatting-and-linting","title":"Formatting and Linting","text":"<p>This repository is configured to use pre-commit to check code, including Black and Flake8 to format and lint code.  It is always good to format before commiting changes.</p> <p>To format:</p> <pre><code>&gt; black .\n</code></pre> <p>To execute flake8 across your changes</p> <pre><code>&gt; flake8 .\n</code></pre> <p>To check your files before committing:</p> <pre><code>&gt; pre-commit run\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>This repository uses mkdocs to generate the documentation site, along with mkdocsstrings-python to extract documentation from code comments.  This project uses Google-formatted docstrings to generate, so please follow that standard when documenting code.</p> <p>Your contribution should be documented.  You can generate documentation locally using the following commands.</p> <pre><code>&gt; pip install -r requirements-mkdocs.txt\n&gt; mkdocs serve\n</code></pre> <p>The documentation site is updated when new releases are published in Github.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>PIP</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install this tool using <code>pip</code>:</p> <pre><code>pip install md-to-conf\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":""},{"location":"getting-started/#basic","title":"Basic","text":"<p>The minimum accepted parameters are the markdown file to upload as well as the Confluence space key you wish to upload to. For the following examples assume 'Test Space' with key: <code>TST</code>.</p> <pre><code>python3 md2conf.py readme.md TST\n</code></pre> <p>Mandatory Confluence parameters can also be set here if not already set as environment variables:</p> <ul> <li>-u --username: Confluence User</li> <li>-p --apikey: Confluence API Key</li> <li>-o --orgname: Confluence Organization</li> </ul> <pre><code>python3 md2conf.py readme.md TST -u basil -p abc123 -o fawltytowers\n</code></pre> <p>Use -h to view a list of all available options.</p>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>To use it, you will need your Confluence username, API key and organization name. To generate an API key go to https://id.atlassian.com/manage/api-tokens.</p> <p>You will also need the organization name that is used in the subdomain. For example the URL: <code>https://fawltytowers.atlassian.net/wiki/</code> would indicate an organization name of fawltytowers.</p> <p>If the organization name contains a dot, it will be considered as a Fully Qualified Domain Name. For example the URL: <code>https://fawltytowers.mydomain.com/</code> would indicate an organization name of fawltytowers.mydomain.com.</p> <p>These can be specified at runtime or set as Confluence environment variables (e.g. add to your <code>~/.profile</code> or <code>~/.bash_profile</code> on Mac OS):</p> <pre><code>export CONFLUENCE_USERNAME='basil'\nexport CONFLUENCE_API_KEY='abc123'\nexport CONFLUENCE_ORGNAME='fawltytowers'\n</code></pre> <p>On Windows, this can be set via system properties.</p>"},{"location":"getting-started/#other-uses","title":"Other Uses","text":"<p>Use -a or --ancestor to designate the name of a page which the page should be created under.</p> <pre><code>python md2conf.py readme.md TST -a \"Parent Page Name\"\n</code></pre> <p>Use -d or --delete to delete the page instead of create it. Obviously this won't work if it doesn't already exist.</p> <p>Use -n or --nossl to specify a non-SSL url, i.e. http:// instead of https://.</p> <p>Use -l or --loglevel to specify a different logging level, i.e DEBUG.</p> <p>Use -s or --simulate to stop processing before interacting with confluence API, i.e. only  converting the markdown document to confluence format.</p> <p>Use --title to set the title for the page, otherwise the title is going to be the first line in the markdown file</p> <p>Use --remove-emojies to emove emojies if there are any. This may be need if the database doesn't support emojies</p>"},{"location":"getting-started/#markdown","title":"Markdown","text":"<p>The original markdown to HTML conversion is performed by the Python markdown library. Additionally, the page name is taken from the first line of  the markdown file, usually assumed to be the title. In the case of this document, the page would be called: Markdown to Confluence Converter.</p> <p>Standard markdown syntax for images and code blocks will be automatically converted. The images are uploaded as attachments and the references updated in the HTML. The code blocks will be converted to the Confluence Code Block macro and also supports syntax highlighting.</p>"},{"location":"getting-started/#doctoc","title":"Doctoc","text":"<p>If present, what is between the doctoc anchor format:</p> <pre><code>&lt;!-- START doctoc ...\n...\n... END doctoc --&gt;\n</code></pre> <p>will be replaced by confluence \"toc\" macro leading to something like:</p> <pre><code>&lt;h2&gt;Table of Content&lt;/h2&gt;\n&lt;p&gt;\n    &lt;ac:structured-macro ac:name=\"toc\"&gt;\n      &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n      &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n    &lt;/ac:structured-macro&gt;\n    &lt;/p&gt;\n</code></pre>"},{"location":"getting-started/#information-note-and-warning-macros","title":"Information, Note and Warning Macros","text":"<p>Warning: Any blockquotes used will implement an information macro. This could potentially harm your formatting.</p> <p>Block quotes in Markdown are rendered as information macros.</p> <pre><code>&gt; This is an info\n</code></pre> <p></p> <pre><code>&gt; Note: This is a note\n</code></pre> <p></p> <pre><code>&gt; Warning: This is a warning\n</code></pre> <p></p> <p>Alternatively, using a custom Markdown syntax also works:</p> <pre><code>~?This is an info.?~\n\n~!This is a note.!~\n\n~%This is a warning.%~\n</code></pre>"},{"location":"api/client-reference/","title":"Client","text":""},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse","title":"<code>CheckedResponse</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>NamedTuple containing page information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class CheckedResponse(typing.NamedTuple):\n\"\"\"\n    NamedTuple containing page information\n\n    \"\"\"\n\n    status_code: int\n\"\"\" Page Id \"\"\"\n\n    data: any\n\"\"\" Generic object from JSON response \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse.data","title":"<code>data: any</code>  <code>instance-attribute</code>","text":"<p>Generic object from JSON response</p>"},{"location":"api/client-reference/#md_to_conf.client.CheckedResponse.status_code","title":"<code>status_code: int</code>  <code>instance-attribute</code>","text":"<p>Page Id</p>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient","title":"<code>ConfluenceApiClient</code>","text":"Source code in <code>md_to_conf/client.py</code> <pre><code>class ConfluenceApiClient:\n    def __init__(\n        self,\n        confluence_api_url: str,\n        username: str,\n        api_key: str,\n        space_key: str,\n        editor_version: int,\n        use_ssl: bool = True,\n    ):\n\"\"\"\n        Constructor\n\n        Args:\n            username:  The Confluence user name associated with the API key\n            api_key: The API key to access Confluence\n            confluence_api_url: The URL to the Confluence site\n            space_key: The Key value for the Space for publishing\n            editor_version: The editor version for page publishing\n            use_ssl:  Whether or not to use SSL.\n\n        \"\"\"\n        self.user_name = username\n        self.api_key = api_key\n        self.confluence_api_url = confluence_api_url\n        self.space_key = space_key\n        self.space_id = -1\n        self.editor_version = editor_version\n        self.use_ssl = use_ssl\n\n    def get_session(self, retry: bool = False, json: bool = True) -&gt; requests.Session:\n\"\"\"\n        Retrieve a `requests` session object\n\n        Args:\n            retry: Configure the request with a retry adapter.\n            json: Configure the request to set Content-Type to 'application/json'\n        Returns:\n            requests.Session: A session from the `requests` module\n\n        \"\"\"\n        session = requests.Session()\n        if retry:\n            retry_max_requests = 5\n            retry_backoff_factor = 0.1\n            retry_status_forcelist = (404, 500, 501, 502, 503, 504)\n            retry = requests.adapters.Retry(\n                total=retry_max_requests,\n                connect=retry_max_requests,\n                read=retry_max_requests,\n                backoff_factor=retry_backoff_factor,\n                status_forcelist=retry_status_forcelist,\n            )\n            adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n            if self.use_ssl:\n                session.mount(\"https://\", adapter)\n            else:\n                session.mount(\"http://\", adapter)\n\n        session.auth = (self.user_name, self.api_key)\n        if json:\n            session.headers.update({\"Content-Type\": \"application/json\"})\n        return session\n\n    def log_not_found(self, object_name: str, log_values: dict[str, str]):\n\"\"\"\n        Write a \"not found\" message to the LOGGER\n\n        Args:\n            object_name: The name to show in the log message\n            log_values: Additional key/value pairs to log\n\n        \"\"\"\n        LOGGER.error(f\"{object_name} not found.\")\n        LOGGER.error(\"Diagnostic Information\")\n        LOGGER.error(f\"\\tURL: {self.confluence_api_url}\")\n        for key in log_values:\n            LOGGER.error(f\"\\t{key}: {log_values[key]}\")\n\n    def check_errors_and_get_json(self, response: requests.Response) -&gt; CheckedResponse:\n\"\"\"\n        Check the response for error codes\n\n        Args:\n            response : The response from a request\n\n        \"\"\"\n        try:\n            response.raise_for_status()\n        except requests.RequestException as err:\n            LOGGER.debug(\"err.response: %s\", err)\n            if response.status_code == 404:\n                return CheckedResponse(404, {\"error\": \"Not Found\"})\n            else:\n                LOGGER.error(\"Error: %d - %s\", response.status_code, response.content)\n                sys.exit(1)\n\n        return CheckedResponse(response.status_code, response.json())\n\n    def update_page(\n        self, page_id: int, title: str, body: str, version: int, parent_id: int\n    ):\n\"\"\"\n        Update a page\n\n        Args:\n            page_id: confluence page id\n            title: confluence page title\n            body: confluence page content\n            version: confluence page version\n            parent_id: confluence parentId\n        \"\"\"\n        LOGGER.info(\"Updating page...\")\n\n        url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n        page_json = {\n            \"id\": page_id,\n            \"type\": \"page\",\n            \"title\": title,\n            \"spaceId\": \"%s\" % self.get_space_id(),\n            \"status\": \"current\",\n            \"body\": {\"value\": body, \"representation\": \"storage\"},\n            \"version\": {\"number\": version + 1, \"minorEdit\": True},\n            \"parentId\": \"%s\" % parent_id,\n        }\n\n        session = self.get_session()\n        response = self.check_errors_and_get_json(\n            session.put(url, data=json.dumps(page_json))\n        )\n\n        if response.status_code == 404:\n            self.log_not_found(\"Page\", {\"Page Id\": \"%d\" % page_id})\n            return False\n\n        if response.status_code == 200:\n            link = \"%s%s\" % (self.confluence_api_url, response.data[\"_links\"][\"webui\"])\n            LOGGER.info(\"Page updated successfully.\")\n            LOGGER.info(\"URL: %s\", link)\n            return True\n        else:\n            LOGGER.error(\"Page could not be updated.\")\n\n    def get_space_id(self) -&gt; int:\n\"\"\"\n        Retrieve the integer space ID for the current self.space_key\n\n        Returns:\n            The integer ID for the space_key of this instance\n\n        \"\"\"\n        if self.space_id &gt; -1:\n            return self.space_id\n\n        url = \"%s/api/v2/spaces?keys=%s\" % (self.confluence_api_url, self.space_key)\n\n        response = self.check_errors_and_get_json(self.get_session().get(url))\n\n        if response.status_code == 404:\n            self.log_not_found(\"Space\", {\"Space Key\": self.space_key})\n        else:\n            if len(response.data[\"results\"]) &gt;= 1:\n                self.space_id = int(response.data[\"results\"][0][\"id\"])\n\n        return self.space_id\n\n    def create_page(self, title: str, body: str, parent_id: int) -&gt; PageInfo:\n\"\"\"\n        Create a new page\n\n        Args:\n            title: confluence page title\n            body: confluence page content\n            parent_id: confluence parentId\n\n        Returns:\n            PageInfo: A num\n        \"\"\"\n        LOGGER.info(\"Creating page...\")\n\n        url = \"%s/api/v2/pages\" % self.confluence_api_url\n\n        space_id = self.get_space_id()\n\n        new_page = {\n            \"title\": title,\n            \"spaceId\": \"%d\" % space_id,\n            \"status\": \"current\",\n            \"body\": {\"value\": body, \"representation\": \"storage\"},\n            \"parentId\": \"%s\" % parent_id,\n            \"metadata\": {\n                \"properties\": {\n                    \"editor\": {\"key\": \"editor\", \"value\": \"v%d\" % self.editor_version}\n                }\n            },\n        }\n\n        LOGGER.debug(\"data: %s\", json.dumps(new_page))\n\n        response = self.check_errors_and_get_json(\n            self.get_session().post(url, data=json.dumps(new_page))\n        )\n\n        if response.status_code == 200:\n            data = response.data\n            space_id = int(data[\"spaceId\"])\n            page_id = int(data[\"id\"])\n            version = data[\"version\"][\"number\"]\n            link = \"%s%s\" % (self.confluence_api_url, data[\"_links\"][\"webui\"])\n\n            LOGGER.info(\"Page created in SpaceId %d with ID: %d.\", space_id, page_id)\n            LOGGER.info(\"URL: %s\", link)\n\n            return PageInfo(page_id, space_id, version, link)\n        else:\n            LOGGER.error(\"Could not create page.\")\n            return PageInfo(0, 0, 0, \"\")\n\n    def delete_page(self, page_id: int):\n\"\"\"\n        Delete a page\n\n        Args:\n            page_id: confluence page id\n        \"\"\"\n        LOGGER.info(\"Deleting page...\")\n        url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n        response = self.get_session().delete(url)\n        response.raise_for_status()\n\n        if response.status_code == 204:\n            LOGGER.info(\"Page %d deleted successfully.\", page_id)\n        else:\n            LOGGER.error(\"Page %d could not be deleted.\", page_id)\n\n    def get_page(self, title: str) -&gt; PageInfo:\n\"\"\"\n        Retrieve page details by title\n\n        Args:\n            title: page title\n        Returns:\n            Confluence page info\n        \"\"\"\n\n        space_id = self.get_space_id()\n\n        LOGGER.info(\"\\tRetrieving page information: %s\", title)\n        url = \"%s/api/v2/spaces/%d/pages?title=%s\" % (\n            self.confluence_api_url,\n            space_id,\n            urllib.parse.quote_plus(title),\n        )\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            self.log_not_found(\"Page\", {\"Space Id\": \"%d\" % space_id})\n        else:\n            data = response.data\n\n            LOGGER.debug(\"data: %s\", str(data))\n\n            if len(data[\"results\"]) &gt;= 1:\n                page_id = int(data[\"results\"][0][\"id\"])\n                space_id = int(data[\"results\"][0][\"spaceId\"])\n                version_num = data[\"results\"][0][\"version\"][\"number\"]\n                link = \"%s%s\" % (\n                    self.confluence_api_url,\n                    data[\"results\"][0][\"_links\"][\"webui\"],\n                )\n\n                page = PageInfo(page_id, space_id, version_num, link)\n                return page\n\n        return PageInfo(0, 0, 0, \"\")\n\n    def get_page_properties(self, page_id: int) -&gt; typing.List[typing.Any]:\n\"\"\"\n        Retrieve page properties by page id\n\n        Args:\n            page_id: pageId\n        Returns:\n            Page Properties Collection\n        \"\"\"\n\n        LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n        url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            self.log_not_found(\"Page Properties\", {\"Page Id\": \"%d\" % page_id})\n        else:\n            return response.data[\"results\"]\n\n        return []\n\n    def update_page_property(self, page_id: int, page_property) -&gt; bool:\n\"\"\"\n        Update page property by page id\n\n        Args:\n            page_id: pageId\n        Returns:\n            True if successful\n        \"\"\"\n\n        property_json = {\n            \"page-id\": page_id,\n            \"key\": page_property[\"key\"],\n            \"value\": page_property[\"value\"],\n            \"version\": {\"number\": page_property[\"version\"], \"minorEdit\": True},\n        }\n\n        if \"id\" in page_property:\n            url = \"%s/api/v2/pages/%d/properties/%s\" % (\n                self.confluence_api_url,\n                page_id,\n                page_property[\"id\"],\n            )\n            property_json.update({\"property-id\": page_property[\"id\"]})\n            LOGGER.info(\n                \"Updating Property ID %s on Page %d: %s=%s\",\n                property_json[\"property-id\"],\n                page_id,\n                property_json[\"key\"],\n                property_json[\"value\"],\n            )\n            response = self.check_errors_and_get_json(\n                self.get_session(retry=True).put(url, data=json.dumps(property_json))\n            )\n        else:\n            url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n            LOGGER.info(\n                \"Adding Property to Page %s: %s=%s\",\n                page_id,\n                property_json[\"key\"],\n                property_json[\"value\"],\n            )\n            response = self.check_errors_and_get_json(\n                self.get_session(retry=True).post(url, data=json.dumps(property_json))\n            )\n\n        if response.status_code != 200:\n            LOGGER.error(\n                \"Unable to add property %s to page %d\", property_json[\"key\"], page_id\n            )\n            return False\n        else:\n            return True\n\n    def get_attachment(self, page_id: int, filename: str) -&gt; str:\n\"\"\"\n        Get page attachment\n\n        Args:\n            page_id: confluence page id\n            filename: attachment filename\n        Returns:\n            The attachment Id, or -1 if not found\n        \"\"\"\n        url = \"%s/api/v2/pages/%d/attachments?filename=%s\" % (\n            self.confluence_api_url,\n            page_id,\n            filename,\n        )\n\n        response = self.get_session().get(url)\n        response.raise_for_status()\n        data = response.json()\n\n        if len(data[\"results\"]) &gt;= 1:\n            att_id = data[\"results\"][0][\"id\"]\n            return att_id\n\n        return \"\"\n\n    def upload_attachment(self, page_id: int, file: str, comment: str) -&gt; bool:\n\"\"\"\n        Upload an attachement\n\n        Args:\n            page_id: confluence page id\n            file: attachment file\n            comment: attachment comment\n        Returns:\n            True if successful, false otherwise\n        \"\"\"\n        if re.search(r\"http.*\", file):\n            return False\n\n        content_type = mimetypes.guess_type(file)[0]\n        filename = os.path.basename(file)\n\n        if not os.path.isfile(file):\n            LOGGER.error(\"File %s cannot be found --&gt; skip \", file)\n            return False\n\n        file_to_upload = {\n            \"comment\": comment,\n            \"file\": (filename, open(file, \"rb\"), content_type, {\"Expires\": \"0\"}),\n        }\n\n        attachment_id = self.get_attachment(page_id, filename)\n        if attachment_id != \"\":\n            url = \"%s/rest/api/content/%d/child/attachment/%s/data\" % (\n                self.confluence_api_url,\n                page_id,\n                attachment_id,\n            )\n        else:\n            url = \"%s/rest/api/content/%d/child/attachment/\" % (\n                self.confluence_api_url,\n                page_id,\n            )\n\n        session = self.get_session(json=False)\n        session.headers.update({\"X-Atlassian-Token\": \"no-check\"})\n\n        LOGGER.info(\"\\tUploading attachment %s...\", filename)\n\n        response = session.post(url, files=file_to_upload)\n        response.raise_for_status()\n\n        return True\n\n    def get_label_info(self, label_name: str) -&gt; LabelInfo:\n\"\"\"\n        Get label information for the given label name\n\n        Args:\n            label_name: pageId\n        Returns:\n            LabelInfo.  If not found, labelInfo will be 0\n        \"\"\"\n\n        LOGGER.debug(\"\\tRetrieving label information: %s\", label_name)\n        url = \"%s/rest/api/label?name=%s\" % (\n            self.confluence_api_url,\n            urllib.parse.quote_plus(label_name),\n        )\n\n        response = self.check_errors_and_get_json(self.get_session().get(url))\n\n        if response.status_code == 404:\n            label = LabelInfo(0, \"\", \"\", \"\")\n        else:\n            data = response.data[\"label\"]\n            label = LabelInfo(\n                int(data[\"id\"]),\n                data[\"name\"],\n                data[\"prefix\"],\n                data[\"label\"],\n            )\n\n        return label\n\n    def add_label(self, page_id: int, label_name: str) -&gt; bool:\n\"\"\"\n        Add the given label to the given page Id\n\n        Args:\n            page_id: pageId\n            label_name: label to be added\n        Returns:\n            True if successful\n        \"\"\"\n        label_info = self.get_label_info(label_name)\n        if label_info.id &gt; 0:\n            prefix = label_info.prefix\n        else:\n            prefix = \"global\"\n\n        add_label_json = {\"prefix\": prefix, \"name\": label_name}\n\n        url = \"%s/rest/api/content/%d/label\" % (self.confluence_api_url, page_id)\n\n        response = self.get_session().post(url, data=json.dumps(add_label_json))\n        response.raise_for_status()\n        return True\n\n    def update_labels(self, page_id: int, labels: typing.List[str]) -&gt; bool:\n\"\"\"\n        Update labels on given page Id\n\n        Args:\n            page_id: pageId\n            labels: labels to be added\n        Returns:\n            True if successful\n        \"\"\"\n\n        LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n        url = \"%s/api/v2/pages/%d/labels\" % (self.confluence_api_url, page_id)\n\n        response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n        if response.status_code == 404:\n            LOGGER.error(\n                \"Error: Error finding existing labels. Check the following are correct:\"\n            )\n            LOGGER.error(\"\\tPage Id : %d\", page_id)\n            LOGGER.error(\"\\tURL: %s\", self.confluence_api_url)\n            return False\n\n        data = response.data\n        for label in labels:\n            found = False\n            for existing_label in data[\"results\"]:\n                if label == existing_label[\"name\"]:\n                    found = True\n\n            if not found:\n                LOGGER.info(\"Adding Label '%s' to Page Id %d\", label, page_id)\n                self.add_label(page_id, label)\n\n            LOGGER.debug(\"property data: %s\", str(data[\"results\"]))\n\n        return data[\"results\"]\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.__init__","title":"<code>__init__(confluence_api_url, username, api_key, space_key, editor_version, use_ssl=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The Confluence user name associated with the API key</p> required <code>api_key</code> <code>str</code> <p>The API key to access Confluence</p> required <code>confluence_api_url</code> <code>str</code> <p>The URL to the Confluence site</p> required <code>space_key</code> <code>str</code> <p>The Key value for the Space for publishing</p> required <code>editor_version</code> <code>int</code> <p>The editor version for page publishing</p> required <code>use_ssl</code> <code>bool</code> <p>Whether or not to use SSL.</p> <code>True</code> Source code in <code>md_to_conf/client.py</code> <pre><code>def __init__(\n    self,\n    confluence_api_url: str,\n    username: str,\n    api_key: str,\n    space_key: str,\n    editor_version: int,\n    use_ssl: bool = True,\n):\n\"\"\"\n    Constructor\n\n    Args:\n        username:  The Confluence user name associated with the API key\n        api_key: The API key to access Confluence\n        confluence_api_url: The URL to the Confluence site\n        space_key: The Key value for the Space for publishing\n        editor_version: The editor version for page publishing\n        use_ssl:  Whether or not to use SSL.\n\n    \"\"\"\n    self.user_name = username\n    self.api_key = api_key\n    self.confluence_api_url = confluence_api_url\n    self.space_key = space_key\n    self.space_id = -1\n    self.editor_version = editor_version\n    self.use_ssl = use_ssl\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.add_label","title":"<code>add_label(page_id, label_name)</code>","text":"<p>Add the given label to the given page Id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <code>label_name</code> <code>str</code> <p>label to be added</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def add_label(self, page_id: int, label_name: str) -&gt; bool:\n\"\"\"\n    Add the given label to the given page Id\n\n    Args:\n        page_id: pageId\n        label_name: label to be added\n    Returns:\n        True if successful\n    \"\"\"\n    label_info = self.get_label_info(label_name)\n    if label_info.id &gt; 0:\n        prefix = label_info.prefix\n    else:\n        prefix = \"global\"\n\n    add_label_json = {\"prefix\": prefix, \"name\": label_name}\n\n    url = \"%s/rest/api/content/%d/label\" % (self.confluence_api_url, page_id)\n\n    response = self.get_session().post(url, data=json.dumps(add_label_json))\n    response.raise_for_status()\n    return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.check_errors_and_get_json","title":"<code>check_errors_and_get_json(response)</code>","text":"<p>Check the response for error codes</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <p>The response from a request</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def check_errors_and_get_json(self, response: requests.Response) -&gt; CheckedResponse:\n\"\"\"\n    Check the response for error codes\n\n    Args:\n        response : The response from a request\n\n    \"\"\"\n    try:\n        response.raise_for_status()\n    except requests.RequestException as err:\n        LOGGER.debug(\"err.response: %s\", err)\n        if response.status_code == 404:\n            return CheckedResponse(404, {\"error\": \"Not Found\"})\n        else:\n            LOGGER.error(\"Error: %d - %s\", response.status_code, response.content)\n            sys.exit(1)\n\n    return CheckedResponse(response.status_code, response.json())\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.create_page","title":"<code>create_page(title, body, parent_id)</code>","text":"<p>Create a new page</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>confluence page title</p> required <code>body</code> <code>str</code> <p>confluence page content</p> required <code>parent_id</code> <code>int</code> <p>confluence parentId</p> required <p>Returns:</p> Name Type Description <code>PageInfo</code> <code>PageInfo</code> <p>A num</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def create_page(self, title: str, body: str, parent_id: int) -&gt; PageInfo:\n\"\"\"\n    Create a new page\n\n    Args:\n        title: confluence page title\n        body: confluence page content\n        parent_id: confluence parentId\n\n    Returns:\n        PageInfo: A num\n    \"\"\"\n    LOGGER.info(\"Creating page...\")\n\n    url = \"%s/api/v2/pages\" % self.confluence_api_url\n\n    space_id = self.get_space_id()\n\n    new_page = {\n        \"title\": title,\n        \"spaceId\": \"%d\" % space_id,\n        \"status\": \"current\",\n        \"body\": {\"value\": body, \"representation\": \"storage\"},\n        \"parentId\": \"%s\" % parent_id,\n        \"metadata\": {\n            \"properties\": {\n                \"editor\": {\"key\": \"editor\", \"value\": \"v%d\" % self.editor_version}\n            }\n        },\n    }\n\n    LOGGER.debug(\"data: %s\", json.dumps(new_page))\n\n    response = self.check_errors_and_get_json(\n        self.get_session().post(url, data=json.dumps(new_page))\n    )\n\n    if response.status_code == 200:\n        data = response.data\n        space_id = int(data[\"spaceId\"])\n        page_id = int(data[\"id\"])\n        version = data[\"version\"][\"number\"]\n        link = \"%s%s\" % (self.confluence_api_url, data[\"_links\"][\"webui\"])\n\n        LOGGER.info(\"Page created in SpaceId %d with ID: %d.\", space_id, page_id)\n        LOGGER.info(\"URL: %s\", link)\n\n        return PageInfo(page_id, space_id, version, link)\n    else:\n        LOGGER.error(\"Could not create page.\")\n        return PageInfo(0, 0, 0, \"\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.delete_page","title":"<code>delete_page(page_id)</code>","text":"<p>Delete a page</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def delete_page(self, page_id: int):\n\"\"\"\n    Delete a page\n\n    Args:\n        page_id: confluence page id\n    \"\"\"\n    LOGGER.info(\"Deleting page...\")\n    url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n    response = self.get_session().delete(url)\n    response.raise_for_status()\n\n    if response.status_code == 204:\n        LOGGER.info(\"Page %d deleted successfully.\", page_id)\n    else:\n        LOGGER.error(\"Page %d could not be deleted.\", page_id)\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_attachment","title":"<code>get_attachment(page_id, filename)</code>","text":"<p>Get page attachment</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>filename</code> <code>str</code> <p>attachment filename</p> required <p>Returns:     The attachment Id, or -1 if not found</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_attachment(self, page_id: int, filename: str) -&gt; str:\n\"\"\"\n    Get page attachment\n\n    Args:\n        page_id: confluence page id\n        filename: attachment filename\n    Returns:\n        The attachment Id, or -1 if not found\n    \"\"\"\n    url = \"%s/api/v2/pages/%d/attachments?filename=%s\" % (\n        self.confluence_api_url,\n        page_id,\n        filename,\n    )\n\n    response = self.get_session().get(url)\n    response.raise_for_status()\n    data = response.json()\n\n    if len(data[\"results\"]) &gt;= 1:\n        att_id = data[\"results\"][0][\"id\"]\n        return att_id\n\n    return \"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_label_info","title":"<code>get_label_info(label_name)</code>","text":"<p>Get label information for the given label name</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>pageId</p> required <p>Returns:     LabelInfo.  If not found, labelInfo will be 0</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_label_info(self, label_name: str) -&gt; LabelInfo:\n\"\"\"\n    Get label information for the given label name\n\n    Args:\n        label_name: pageId\n    Returns:\n        LabelInfo.  If not found, labelInfo will be 0\n    \"\"\"\n\n    LOGGER.debug(\"\\tRetrieving label information: %s\", label_name)\n    url = \"%s/rest/api/label?name=%s\" % (\n        self.confluence_api_url,\n        urllib.parse.quote_plus(label_name),\n    )\n\n    response = self.check_errors_and_get_json(self.get_session().get(url))\n\n    if response.status_code == 404:\n        label = LabelInfo(0, \"\", \"\", \"\")\n    else:\n        data = response.data[\"label\"]\n        label = LabelInfo(\n            int(data[\"id\"]),\n            data[\"name\"],\n            data[\"prefix\"],\n            data[\"label\"],\n        )\n\n    return label\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_page","title":"<code>get_page(title)</code>","text":"<p>Retrieve page details by title</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>page title</p> required <p>Returns:     Confluence page info</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_page(self, title: str) -&gt; PageInfo:\n\"\"\"\n    Retrieve page details by title\n\n    Args:\n        title: page title\n    Returns:\n        Confluence page info\n    \"\"\"\n\n    space_id = self.get_space_id()\n\n    LOGGER.info(\"\\tRetrieving page information: %s\", title)\n    url = \"%s/api/v2/spaces/%d/pages?title=%s\" % (\n        self.confluence_api_url,\n        space_id,\n        urllib.parse.quote_plus(title),\n    )\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        self.log_not_found(\"Page\", {\"Space Id\": \"%d\" % space_id})\n    else:\n        data = response.data\n\n        LOGGER.debug(\"data: %s\", str(data))\n\n        if len(data[\"results\"]) &gt;= 1:\n            page_id = int(data[\"results\"][0][\"id\"])\n            space_id = int(data[\"results\"][0][\"spaceId\"])\n            version_num = data[\"results\"][0][\"version\"][\"number\"]\n            link = \"%s%s\" % (\n                self.confluence_api_url,\n                data[\"results\"][0][\"_links\"][\"webui\"],\n            )\n\n            page = PageInfo(page_id, space_id, version_num, link)\n            return page\n\n    return PageInfo(0, 0, 0, \"\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_page_properties","title":"<code>get_page_properties(page_id)</code>","text":"<p>Retrieve page properties by page id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <p>Returns:     Page Properties Collection</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_page_properties(self, page_id: int) -&gt; typing.List[typing.Any]:\n\"\"\"\n    Retrieve page properties by page id\n\n    Args:\n        page_id: pageId\n    Returns:\n        Page Properties Collection\n    \"\"\"\n\n    LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n    url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        self.log_not_found(\"Page Properties\", {\"Page Id\": \"%d\" % page_id})\n    else:\n        return response.data[\"results\"]\n\n    return []\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_session","title":"<code>get_session(retry=False, json=True)</code>","text":"<p>Retrieve a <code>requests</code> session object</p> <p>Parameters:</p> Name Type Description Default <code>retry</code> <code>bool</code> <p>Configure the request with a retry adapter.</p> <code>False</code> <code>json</code> <code>bool</code> <p>Configure the request to set Content-Type to 'application/json'</p> <code>True</code> <p>Returns:     requests.Session: A session from the <code>requests</code> module</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_session(self, retry: bool = False, json: bool = True) -&gt; requests.Session:\n\"\"\"\n    Retrieve a `requests` session object\n\n    Args:\n        retry: Configure the request with a retry adapter.\n        json: Configure the request to set Content-Type to 'application/json'\n    Returns:\n        requests.Session: A session from the `requests` module\n\n    \"\"\"\n    session = requests.Session()\n    if retry:\n        retry_max_requests = 5\n        retry_backoff_factor = 0.1\n        retry_status_forcelist = (404, 500, 501, 502, 503, 504)\n        retry = requests.adapters.Retry(\n            total=retry_max_requests,\n            connect=retry_max_requests,\n            read=retry_max_requests,\n            backoff_factor=retry_backoff_factor,\n            status_forcelist=retry_status_forcelist,\n        )\n        adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n        if self.use_ssl:\n            session.mount(\"https://\", adapter)\n        else:\n            session.mount(\"http://\", adapter)\n\n    session.auth = (self.user_name, self.api_key)\n    if json:\n        session.headers.update({\"Content-Type\": \"application/json\"})\n    return session\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.get_space_id","title":"<code>get_space_id()</code>","text":"<p>Retrieve the integer space ID for the current self.space_key</p> <p>Returns:</p> Type Description <code>int</code> <p>The integer ID for the space_key of this instance</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def get_space_id(self) -&gt; int:\n\"\"\"\n    Retrieve the integer space ID for the current self.space_key\n\n    Returns:\n        The integer ID for the space_key of this instance\n\n    \"\"\"\n    if self.space_id &gt; -1:\n        return self.space_id\n\n    url = \"%s/api/v2/spaces?keys=%s\" % (self.confluence_api_url, self.space_key)\n\n    response = self.check_errors_and_get_json(self.get_session().get(url))\n\n    if response.status_code == 404:\n        self.log_not_found(\"Space\", {\"Space Key\": self.space_key})\n    else:\n        if len(response.data[\"results\"]) &gt;= 1:\n            self.space_id = int(response.data[\"results\"][0][\"id\"])\n\n    return self.space_id\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.log_not_found","title":"<code>log_not_found(object_name, log_values)</code>","text":"<p>Write a \"not found\" message to the LOGGER</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>The name to show in the log message</p> required <code>log_values</code> <code>dict[str, str]</code> <p>Additional key/value pairs to log</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def log_not_found(self, object_name: str, log_values: dict[str, str]):\n\"\"\"\n    Write a \"not found\" message to the LOGGER\n\n    Args:\n        object_name: The name to show in the log message\n        log_values: Additional key/value pairs to log\n\n    \"\"\"\n    LOGGER.error(f\"{object_name} not found.\")\n    LOGGER.error(\"Diagnostic Information\")\n    LOGGER.error(f\"\\tURL: {self.confluence_api_url}\")\n    for key in log_values:\n        LOGGER.error(f\"\\t{key}: {log_values[key]}\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_labels","title":"<code>update_labels(page_id, labels)</code>","text":"<p>Update labels on given page Id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <code>labels</code> <code>List[str]</code> <p>labels to be added</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def update_labels(self, page_id: int, labels: typing.List[str]) -&gt; bool:\n\"\"\"\n    Update labels on given page Id\n\n    Args:\n        page_id: pageId\n        labels: labels to be added\n    Returns:\n        True if successful\n    \"\"\"\n\n    LOGGER.info(\"\\tRetrieving page property information: %d\", page_id)\n    url = \"%s/api/v2/pages/%d/labels\" % (self.confluence_api_url, page_id)\n\n    response = self.check_errors_and_get_json(self.get_session(retry=True).get(url))\n    if response.status_code == 404:\n        LOGGER.error(\n            \"Error: Error finding existing labels. Check the following are correct:\"\n        )\n        LOGGER.error(\"\\tPage Id : %d\", page_id)\n        LOGGER.error(\"\\tURL: %s\", self.confluence_api_url)\n        return False\n\n    data = response.data\n    for label in labels:\n        found = False\n        for existing_label in data[\"results\"]:\n            if label == existing_label[\"name\"]:\n                found = True\n\n        if not found:\n            LOGGER.info(\"Adding Label '%s' to Page Id %d\", label, page_id)\n            self.add_label(page_id, label)\n\n        LOGGER.debug(\"property data: %s\", str(data[\"results\"]))\n\n    return data[\"results\"]\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_page","title":"<code>update_page(page_id, title, body, version, parent_id)</code>","text":"<p>Update a page</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>title</code> <code>str</code> <p>confluence page title</p> required <code>body</code> <code>str</code> <p>confluence page content</p> required <code>version</code> <code>int</code> <p>confluence page version</p> required <code>parent_id</code> <code>int</code> <p>confluence parentId</p> required Source code in <code>md_to_conf/client.py</code> <pre><code>def update_page(\n    self, page_id: int, title: str, body: str, version: int, parent_id: int\n):\n\"\"\"\n    Update a page\n\n    Args:\n        page_id: confluence page id\n        title: confluence page title\n        body: confluence page content\n        version: confluence page version\n        parent_id: confluence parentId\n    \"\"\"\n    LOGGER.info(\"Updating page...\")\n\n    url = \"%s/api/v2/pages/%d\" % (self.confluence_api_url, page_id)\n\n    page_json = {\n        \"id\": page_id,\n        \"type\": \"page\",\n        \"title\": title,\n        \"spaceId\": \"%s\" % self.get_space_id(),\n        \"status\": \"current\",\n        \"body\": {\"value\": body, \"representation\": \"storage\"},\n        \"version\": {\"number\": version + 1, \"minorEdit\": True},\n        \"parentId\": \"%s\" % parent_id,\n    }\n\n    session = self.get_session()\n    response = self.check_errors_and_get_json(\n        session.put(url, data=json.dumps(page_json))\n    )\n\n    if response.status_code == 404:\n        self.log_not_found(\"Page\", {\"Page Id\": \"%d\" % page_id})\n        return False\n\n    if response.status_code == 200:\n        link = \"%s%s\" % (self.confluence_api_url, response.data[\"_links\"][\"webui\"])\n        LOGGER.info(\"Page updated successfully.\")\n        LOGGER.info(\"URL: %s\", link)\n        return True\n    else:\n        LOGGER.error(\"Page could not be updated.\")\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.update_page_property","title":"<code>update_page_property(page_id, page_property)</code>","text":"<p>Update page property by page id</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>pageId</p> required <p>Returns:     True if successful</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def update_page_property(self, page_id: int, page_property) -&gt; bool:\n\"\"\"\n    Update page property by page id\n\n    Args:\n        page_id: pageId\n    Returns:\n        True if successful\n    \"\"\"\n\n    property_json = {\n        \"page-id\": page_id,\n        \"key\": page_property[\"key\"],\n        \"value\": page_property[\"value\"],\n        \"version\": {\"number\": page_property[\"version\"], \"minorEdit\": True},\n    }\n\n    if \"id\" in page_property:\n        url = \"%s/api/v2/pages/%d/properties/%s\" % (\n            self.confluence_api_url,\n            page_id,\n            page_property[\"id\"],\n        )\n        property_json.update({\"property-id\": page_property[\"id\"]})\n        LOGGER.info(\n            \"Updating Property ID %s on Page %d: %s=%s\",\n            property_json[\"property-id\"],\n            page_id,\n            property_json[\"key\"],\n            property_json[\"value\"],\n        )\n        response = self.check_errors_and_get_json(\n            self.get_session(retry=True).put(url, data=json.dumps(property_json))\n        )\n    else:\n        url = \"%s/api/v2/pages/%d/properties\" % (self.confluence_api_url, page_id)\n        LOGGER.info(\n            \"Adding Property to Page %s: %s=%s\",\n            page_id,\n            property_json[\"key\"],\n            property_json[\"value\"],\n        )\n        response = self.check_errors_and_get_json(\n            self.get_session(retry=True).post(url, data=json.dumps(property_json))\n        )\n\n    if response.status_code != 200:\n        LOGGER.error(\n            \"Unable to add property %s to page %d\", property_json[\"key\"], page_id\n        )\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.ConfluenceApiClient.upload_attachment","title":"<code>upload_attachment(page_id, file, comment)</code>","text":"<p>Upload an attachement</p> <p>Parameters:</p> Name Type Description Default <code>page_id</code> <code>int</code> <p>confluence page id</p> required <code>file</code> <code>str</code> <p>attachment file</p> required <code>comment</code> <code>str</code> <p>attachment comment</p> required <p>Returns:     True if successful, false otherwise</p> Source code in <code>md_to_conf/client.py</code> <pre><code>def upload_attachment(self, page_id: int, file: str, comment: str) -&gt; bool:\n\"\"\"\n    Upload an attachement\n\n    Args:\n        page_id: confluence page id\n        file: attachment file\n        comment: attachment comment\n    Returns:\n        True if successful, false otherwise\n    \"\"\"\n    if re.search(r\"http.*\", file):\n        return False\n\n    content_type = mimetypes.guess_type(file)[0]\n    filename = os.path.basename(file)\n\n    if not os.path.isfile(file):\n        LOGGER.error(\"File %s cannot be found --&gt; skip \", file)\n        return False\n\n    file_to_upload = {\n        \"comment\": comment,\n        \"file\": (filename, open(file, \"rb\"), content_type, {\"Expires\": \"0\"}),\n    }\n\n    attachment_id = self.get_attachment(page_id, filename)\n    if attachment_id != \"\":\n        url = \"%s/rest/api/content/%d/child/attachment/%s/data\" % (\n            self.confluence_api_url,\n            page_id,\n            attachment_id,\n        )\n    else:\n        url = \"%s/rest/api/content/%d/child/attachment/\" % (\n            self.confluence_api_url,\n            page_id,\n        )\n\n    session = self.get_session(json=False)\n    session.headers.update({\"X-Atlassian-Token\": \"no-check\"})\n\n    LOGGER.info(\"\\tUploading attachment %s...\", filename)\n\n    response = session.post(url, files=file_to_upload)\n    response.raise_for_status()\n\n    return True\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo","title":"<code>LabelInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>NamedTuple containing label information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class LabelInfo(typing.NamedTuple):\n\"\"\"\n    NamedTuple containing label information\n\n    \"\"\"\n\n    id: int\n\"\"\" Label Id \"\"\"\n\n    name: str\n\"\"\" The name of the label \"\"\"\n\n    prefix: str\n\"\"\" The prefix of the label \"\"\"\n\n    label: str\n\"\"\" The translated label \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>Label Id</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.label","title":"<code>label: str</code>  <code>instance-attribute</code>","text":"<p>The translated label</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The name of the label</p>"},{"location":"api/client-reference/#md_to_conf.client.LabelInfo.prefix","title":"<code>prefix: str</code>  <code>instance-attribute</code>","text":"<p>The prefix of the label</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo","title":"<code>PageInfo</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>NamedTuple containing page information</p> Source code in <code>md_to_conf/client.py</code> <pre><code>class PageInfo(typing.NamedTuple):\n\"\"\"\n    NamedTuple containing page information\n\n    \"\"\"\n\n    id: int\n\"\"\" Page Id \"\"\"\n\n    spaceId: int\n\"\"\" Space Id \"\"\"\n\n    version: int\n\"\"\" Page Version \"\"\"\n\n    link: str\n\"\"\" Page Link \"\"\"\n</code></pre>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>Page Id</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.link","title":"<code>link: str</code>  <code>instance-attribute</code>","text":"<p>Page Link</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.spaceId","title":"<code>spaceId: int</code>  <code>instance-attribute</code>","text":"<p>Space Id</p>"},{"location":"api/client-reference/#md_to_conf.client.PageInfo.version","title":"<code>version: int</code>  <code>instance-attribute</code>","text":"<p>Page Version</p>"},{"location":"api/converter-reference/","title":"Converter","text":""},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter","title":"<code>MarkdownConverter</code>","text":"<p>Wrapper for the <code>markdown</code> module that converts Markdown into HTML</p> <p>Provides some additional functions for advanced HTML processing</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>class MarkdownConverter:\n\"\"\"\n    Wrapper for the `markdown` module that converts Markdown into HTML\n\n    Provides some additional functions for advanced HTML processing\n\n    \"\"\"\n\n    def __init__(self, md_file: str, api_url: str, md_source: str, editor_version: int):\n\"\"\"\n        Constructor\n\n        Args:\n            md_file: Path the the Markdown file\n            api_url: Path the the Confluence API, used to build link urls\n            md_source: MD Source format: current choices are `default` and `bitbucket`\n            editor_version: Version to use for the editor\n        \"\"\"\n        self.md_file = md_file\n        self.api_url = api_url\n        self.md_source = md_source\n        self.editor_version = editor_version\n\n    def convert_md_to_conf_html(\n        self,\n        has_title: bool = False,\n        remove_emojies: bool = False,\n        add_contents: bool = False,\n    ):\n\"\"\"\n        Convert the Markdown file to Confluence HTML\n\n        Args:\n            has_title: Was a title provided via the CLI?\n            remove_emojies: Should emojies be removed?\n            add_contents: Should a contents section be added to the page\n\n        Returns:\n            A string representing HTML for the Markdown page\n        \"\"\"\n        html = self.get_html_from_markdown()\n        if not has_title:\n            html = \"\\n\".join(html.split(\"\\n\")[1:])\n\n        html = self.create_table_of_content(html)\n        html = self.convert_info_macros(html)\n        html = self.convert_comment_block(html)\n        html = self.convert_code_block(html)\n\n        if remove_emojies:\n            html = self.remove_emojies(html)\n\n        if add_contents:\n            html = self.add_contents(html)\n\n        html = self.process_refs(html)\n        return html\n\n    def get_html_from_markdown(self) -&gt; str:\n\"\"\"\n        Convert the Markdown file to HTML.  This is a wrapper\n        around the markdown library\n\n        Returns:\n            A string representing HTML for the Markdown page\n        \"\"\"\n        with codecs.open(self.md_file, \"r\", \"utf-8\") as mdfile:\n            markdown_content = mdfile.read()\n            html = markdown.markdown(\n                markdown_content,\n                extensions=[\n                    \"tables\",\n                    \"fenced_code\",\n                    \"footnotes\",\n                    \"mdx_truly_sane_lists\",\n                ],\n            )\n\n        return html\n\n    def convert_comment_block(self, html: str) -&gt; str:\n\"\"\"\n        Convert markdown code bloc to Confluence hidden comment\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        open_tag = \"&lt;ac:placeholder&gt;\"\n        close_tag = \"&lt;/ac:placeholder&gt;\"\n        html = html.replace(\"&lt;!--\", open_tag).replace(\"--&gt;\", close_tag)\n        return html\n\n    def create_table_of_content(self, html: str) -&gt; str:\n\"\"\"\n        Check for the string '[TOC]' and replaces it the\n        Confluence \"Table of Content\" macro\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        html = str.replace(\n            html,\n            r\"&lt;p&gt;[TOC]&lt;/p&gt;\",\n            '&lt;p&gt;&lt;ac:structured-macro ac:name=\"toc\" ac:schema-version=\"1\"/&gt;&lt;/p&gt;',\n        )\n\n        return html\n\n    def convert_code_block(self, html: str) -&gt; str:\n\"\"\"\n        Convert html code blocks to Confluence macros\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        LOGGER.debug(\"HTML pre code block\")\n        LOGGER.debug(html)\n        code_blocks = re.findall(r\"&lt;pre&gt;&lt;code.*?&gt;.*?&lt;/code&gt;&lt;/pre&gt;\", html, re.DOTALL)\n        if code_blocks:\n            for tag in code_blocks:\n                conf_ml = '&lt;ac:structured-macro ac:name=\"code\"&gt;'\n                conf_ml = (\n                    conf_ml + '&lt;ac:parameter ac:name=\"theme\"&gt;Midnight&lt;/ac:parameter&gt;'\n                )\n                conf_ml = (\n                    conf_ml + '&lt;ac:parameter ac:name=\"linenumbers\"&gt;true&lt;/ac:parameter&gt;'\n                )\n\n                lang = re.search('code class=\"language-(.*)\"', tag)\n                if lang:\n                    lang = lang.group(1)\n                else:\n                    lang = \"none\"\n\n                conf_ml = (\n                    conf_ml\n                    + '&lt;ac:parameter ac:name=\"language\"&gt;'\n                    + lang\n                    + \"&lt;/ac:parameter&gt;\"\n                )\n                content = re.search(\n                    r\"&lt;pre&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;\", tag, re.DOTALL\n                ).group(1)\n                content = (\n                    \"&lt;ac:plain-text-body&gt;&lt;![CDATA[\"\n                    + content\n                    + \"]]&gt;&lt;/ac:plain-text-body&gt;\"\n                )\n                conf_ml = conf_ml + content + \"&lt;/ac:structured-macro&gt;\"\n                conf_ml = conf_ml.replace(\"&amp;lt;\", \"&lt;\").replace(\"&amp;gt;\", \"&gt;\")\n                conf_ml = conf_ml.replace(\"&amp;quot;\", '\"').replace(\"&amp;amp;\", \"&amp;\")\n\n                html = html.replace(tag, conf_ml)\n\n        return html\n\n    def remove_emojies(self, html: str) -&gt; str:\n\"\"\"\n        Remove emojies if there are any\n\n        Args:\n            html: string\n        Returns:\n            modified html string\n        \"\"\"\n        regrex_pattern = re.compile(\n            pattern=\"[\"\n            \"\\U0001F600-\\U0001F64F\"  # emoticons\n            \"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n            \"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n            \"\\U0001F1E0-\\U0001F1FF\"  # flags (iOS)\n            \"]+\",\n            flags=re.UNICODE,\n        )\n        return regrex_pattern.sub(r\"\", html)\n\n    def convert_info_macros(self, html: str) -&gt; str:\n\"\"\"\n        Converts html for info, note or warning macros\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        info_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"info\"&gt;&lt;ac:rich-text-body&gt;&lt;p&gt;'\n        note_tag = info_tag.replace(\"info\", \"note\")\n        warning_tag = info_tag.replace(\"info\", \"warning\")\n        close_tag = \"&lt;/p&gt;&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;\"\n\n        # Custom tags converted into macros\n        html = html.replace(\"&lt;p&gt;~?\", info_tag).replace(\"?~&lt;/p&gt;\", close_tag)\n        html = html.replace(\"&lt;p&gt;~!\", note_tag).replace(\"!~&lt;/p&gt;\", close_tag)\n        html = html.replace(\"&lt;p&gt;~%\", warning_tag).replace(\"%~&lt;/p&gt;\", close_tag)\n\n        # Convert block quotes into macros\n        quotes = re.findall(\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n        if quotes:\n            for quote in quotes:\n                note = re.search(\"^&lt;.*&gt;Note\", quote.strip(), re.IGNORECASE)\n                warning = re.search(\"^&lt;.*&gt;Warning\", quote.strip(), re.IGNORECASE)\n\n                if note:\n                    clean_tag = self.strip_type(quote, \"Note\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", note_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n                elif warning:\n                    clean_tag = self.strip_type(quote, \"Warning\")\n                    macro_tag = (\n                        clean_tag.replace(\"&lt;p&gt;\", warning_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n                else:\n                    macro_tag = (\n                        quote.replace(\"&lt;p&gt;\", info_tag)\n                        .replace(\"&lt;/p&gt;\", close_tag)\n                        .strip()\n                    )\n\n                html = html.replace(\"&lt;blockquote&gt;%s&lt;/blockquote&gt;\" % quote, macro_tag)\n\n        # Convert doctoc to toc confluence macro\n        html = self.convert_doctoc(html)\n\n        return html\n\n    def convert_doctoc(self, html: str) -&gt; str:\n\"\"\"\n        Convert doctoc to confluence macro\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n\n        toc_tag = \"\"\"&lt;p&gt;\n        &lt;ac:structured-macro ac:name=\"toc\"&gt;\n        &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n        &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n        &lt;/ac:structured-macro&gt;\n        &lt;/p&gt;\"\"\"\n\n        html = re.sub(\n            r\"\\&lt;\\!\\-\\- START doctoc.*END doctoc \\-\\-\\&gt;\", toc_tag, html, flags=re.DOTALL\n        )\n\n        return html\n\n    def strip_type(self, tag: str, tagtype: str) -&gt; str:\n\"\"\"\n        Strips Note or Warning tags from html in various formats\n\n        Args:\n            tag: tag name\n            tagtype: tag type\n        Returns:\n            modified tag\n        \"\"\"\n        tag = re.sub(r\"%s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n        tag = re.sub(r\"%s\\s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n        tag = re.sub(r\"&lt;.*?&gt;%s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;.*?&gt;%s\\s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n        string_start = re.search(\"&lt;[^&gt;]*&gt;\", tag)\n        tag = self.upper_chars(tag, [string_start.end()])\n        return tag\n\n    def upper_chars(self, string: str, indices: typing.List[int]) -&gt; str:\n\"\"\"\n        Make characters uppercase in string\n\n        Args:\n            string: string to modify\n            indices: character indice to change to uppercase\n        Returns:\n            uppercased string\n        \"\"\"\n        upper_string = \"\".join(\n            c.upper() if i in indices else c for i, c in enumerate(string)\n        )\n        return upper_string\n\n    def slug(self, string: str, lowercase: bool) -&gt; str:\n\"\"\"\n        Creates a slug string\n\n        Args:\n            string: string to modify\n            lowercase: whether string has to be lowercased\n        Returns:\n            slug string\n        \"\"\"\n\n        slug_string = string\n        if lowercase:\n            slug_string = string.lower()\n\n        # Remove all html code tags\n        slug_string = re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", slug_string)\n        # Remove html code like '&amp;amp;'\n        slug_string = re.sub(r\"&amp;[a-z]+;\", \"\", slug_string)\n        # Replace all spaces ( ) with dash (-)\n        slug_string = str.replace(slug_string, \" \", \"-\")\n\n        # Remove all special chars, except for dash (-)\n        slug_string = re.sub(r\"[^a-zA-Z0-9-]\", \"\", slug_string)\n\n        return slug_string\n\n    def process_headers(self, ref_prefix, ref_postfix, headers):\n        headers_map = {}\n        headers_count = {}\n\n        for header in headers:\n            key = ref_prefix + self.slug(header, True)\n\n            if self.editor_version == 1:\n                value = re.sub(r\"(&lt;.+&gt;| )\", \"\", header)\n            if self.editor_version == 2:\n                value = self.slug(header, False)\n\n            if key in headers_map:\n                alt_count = headers_count[key]\n\n                alt_key = key + (ref_postfix % alt_count)\n                alt_value = value + (\".%s\" % alt_count)\n\n                headers_map[alt_key] = alt_value\n                headers_count[key] = alt_count + 1\n            else:\n                headers_map[key] = value\n                headers_count[key] = 1\n\n        return headers_map\n\n    def process_links(\n        self, html, links, headers_map, space_id: int, page_id: int, title: str\n    ):\n        for link in links:\n            matches = re.search(r'&lt;a href=\"(#.+?)\"&gt;(.+?)&lt;/a&gt;', link)\n            ref = matches.group(1)\n            alt = matches.group(2)\n\n            result_ref = headers_map.get(ref)\n\n            if result_ref:\n                base_uri = \"%s/spaces/%d/pages/%d/%s\" % (\n                    self.api_url,\n                    space_id,\n                    page_id,\n                    \"+\".join(title.split()),\n                )\n                if self.editor_version == 1:\n                    replacement = (\n                        '&lt;ac:link ac:anchor=\"%s\"&gt;'\n                        \"&lt;ac:plain-text-link-body&gt;\"\n                        \"&lt;![CDATA[%s]]&gt;&lt;/ac:plain-text-link-body&gt;&lt;/ac:link&gt;\"\n                        % (result_ref, re.sub(r\"( *&lt;.+&gt; *)\", \" \", alt))\n                    )\n                if self.editor_version == 2:\n                    replacement_uri = \"%s#%s\" % (base_uri, result_ref)\n                    replacement = '&lt;a href=\"%s\" title=\"%s\"&gt;%s&lt;/a&gt;' % (\n                        replacement_uri,\n                        alt,\n                        alt,\n                    )\n\n                html = html.replace(link, replacement)\n\n        return html\n\n    def process_refs(self, html: str) -&gt; str:\n\"\"\"\n        Process references\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        refs = re.findall(r\"\\n(\\[\\^(\\d)\\].*)|&lt;p&gt;(\\[\\^(\\d)\\].*)\", html)\n\n        if refs:\n            for ref in refs:\n                if ref[0]:\n                    full_ref = ref[0].replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                    ref_id = ref[1]\n                else:\n                    full_ref = ref[2]\n                    ref_id = ref[3]\n\n                full_ref = full_ref.replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                html = html.replace(full_ref, \"\")\n                href = re.search('href=\"(.*?)\"', full_ref).group(1)\n\n                superscript = '&lt;a id=\"test\" href=\"%s\"&gt;&lt;sup&gt;%s&lt;/sup&gt;&lt;/a&gt;' % (\n                    href,\n                    ref_id,\n                )\n                html = html.replace(\"[^%s]\" % ref_id, superscript)\n\n        return html\n\n    # Scan for images and upload as attachments if found\n\n    def add_contents(self, html: str) -&gt; str:\n\"\"\"\n        Add contents page\n\n        Args:\n            html: html string\n        Returns:\n            modified html string\n        \"\"\"\n        contents_markup = (\n            '&lt;ac:structured-macro ac:name=\"toc\"&gt;\\n&lt;ac:parameter ac:name=\"printable\"&gt;'\n            'true&lt;/ac:parameter&gt;\\n&lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup + '&lt;ac:parameter ac:name=\"maxLevel\"&gt;5&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup\n            + '&lt;ac:parameter ac:name=\"class\"&gt;rm-contents&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"exclude\"&gt;&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;'\n        )\n        contents_markup = (\n            contents_markup + '&lt;ac:parameter ac:name=\"outline\"&gt;false&lt;/ac:parameter&gt;\\n'\n            '&lt;ac:parameter ac:name=\"include\"&gt;&lt;/ac:parameter&gt;\\n'\n            \"&lt;/ac:structured-macro&gt;\"\n        )\n\n        html = contents_markup + \"\\n\" + html\n        return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.__init__","title":"<code>__init__(md_file, api_url, md_source, editor_version)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>md_file</code> <code>str</code> <p>Path the the Markdown file</p> required <code>api_url</code> <code>str</code> <p>Path the the Confluence API, used to build link urls</p> required <code>md_source</code> <code>str</code> <p>MD Source format: current choices are <code>default</code> and <code>bitbucket</code></p> required <code>editor_version</code> <code>int</code> <p>Version to use for the editor</p> required Source code in <code>md_to_conf/converter.py</code> <pre><code>def __init__(self, md_file: str, api_url: str, md_source: str, editor_version: int):\n\"\"\"\n    Constructor\n\n    Args:\n        md_file: Path the the Markdown file\n        api_url: Path the the Confluence API, used to build link urls\n        md_source: MD Source format: current choices are `default` and `bitbucket`\n        editor_version: Version to use for the editor\n    \"\"\"\n    self.md_file = md_file\n    self.api_url = api_url\n    self.md_source = md_source\n    self.editor_version = editor_version\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.add_contents","title":"<code>add_contents(html)</code>","text":"<p>Add contents page</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def add_contents(self, html: str) -&gt; str:\n\"\"\"\n    Add contents page\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    contents_markup = (\n        '&lt;ac:structured-macro ac:name=\"toc\"&gt;\\n&lt;ac:parameter ac:name=\"printable\"&gt;'\n        'true&lt;/ac:parameter&gt;\\n&lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup + '&lt;ac:parameter ac:name=\"maxLevel\"&gt;5&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup\n        + '&lt;ac:parameter ac:name=\"class\"&gt;rm-contents&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"exclude\"&gt;&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;'\n    )\n    contents_markup = (\n        contents_markup + '&lt;ac:parameter ac:name=\"outline\"&gt;false&lt;/ac:parameter&gt;\\n'\n        '&lt;ac:parameter ac:name=\"include\"&gt;&lt;/ac:parameter&gt;\\n'\n        \"&lt;/ac:structured-macro&gt;\"\n    )\n\n    html = contents_markup + \"\\n\" + html\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_code_block","title":"<code>convert_code_block(html)</code>","text":"<p>Convert html code blocks to Confluence macros</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_code_block(self, html: str) -&gt; str:\n\"\"\"\n    Convert html code blocks to Confluence macros\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    LOGGER.debug(\"HTML pre code block\")\n    LOGGER.debug(html)\n    code_blocks = re.findall(r\"&lt;pre&gt;&lt;code.*?&gt;.*?&lt;/code&gt;&lt;/pre&gt;\", html, re.DOTALL)\n    if code_blocks:\n        for tag in code_blocks:\n            conf_ml = '&lt;ac:structured-macro ac:name=\"code\"&gt;'\n            conf_ml = (\n                conf_ml + '&lt;ac:parameter ac:name=\"theme\"&gt;Midnight&lt;/ac:parameter&gt;'\n            )\n            conf_ml = (\n                conf_ml + '&lt;ac:parameter ac:name=\"linenumbers\"&gt;true&lt;/ac:parameter&gt;'\n            )\n\n            lang = re.search('code class=\"language-(.*)\"', tag)\n            if lang:\n                lang = lang.group(1)\n            else:\n                lang = \"none\"\n\n            conf_ml = (\n                conf_ml\n                + '&lt;ac:parameter ac:name=\"language\"&gt;'\n                + lang\n                + \"&lt;/ac:parameter&gt;\"\n            )\n            content = re.search(\n                r\"&lt;pre&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;\", tag, re.DOTALL\n            ).group(1)\n            content = (\n                \"&lt;ac:plain-text-body&gt;&lt;![CDATA[\"\n                + content\n                + \"]]&gt;&lt;/ac:plain-text-body&gt;\"\n            )\n            conf_ml = conf_ml + content + \"&lt;/ac:structured-macro&gt;\"\n            conf_ml = conf_ml.replace(\"&amp;lt;\", \"&lt;\").replace(\"&amp;gt;\", \"&gt;\")\n            conf_ml = conf_ml.replace(\"&amp;quot;\", '\"').replace(\"&amp;amp;\", \"&amp;\")\n\n            html = html.replace(tag, conf_ml)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_comment_block","title":"<code>convert_comment_block(html)</code>","text":"<p>Convert markdown code bloc to Confluence hidden comment</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_comment_block(self, html: str) -&gt; str:\n\"\"\"\n    Convert markdown code bloc to Confluence hidden comment\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    open_tag = \"&lt;ac:placeholder&gt;\"\n    close_tag = \"&lt;/ac:placeholder&gt;\"\n    html = html.replace(\"&lt;!--\", open_tag).replace(\"--&gt;\", close_tag)\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_doctoc","title":"<code>convert_doctoc(html)</code>","text":"<p>Convert doctoc to confluence macro</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_doctoc(self, html: str) -&gt; str:\n\"\"\"\n    Convert doctoc to confluence macro\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n\n    toc_tag = \"\"\"&lt;p&gt;\n    &lt;ac:structured-macro ac:name=\"toc\"&gt;\n    &lt;ac:parameter ac:name=\"printable\"&gt;true&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"style\"&gt;disc&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"maxLevel\"&gt;7&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"minLevel\"&gt;1&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"type\"&gt;list&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"outline\"&gt;clear&lt;/ac:parameter&gt;\n    &lt;ac:parameter ac:name=\"include\"&gt;.*&lt;/ac:parameter&gt;\n    &lt;/ac:structured-macro&gt;\n    &lt;/p&gt;\"\"\"\n\n    html = re.sub(\n        r\"\\&lt;\\!\\-\\- START doctoc.*END doctoc \\-\\-\\&gt;\", toc_tag, html, flags=re.DOTALL\n    )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_info_macros","title":"<code>convert_info_macros(html)</code>","text":"<p>Converts html for info, note or warning macros</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_info_macros(self, html: str) -&gt; str:\n\"\"\"\n    Converts html for info, note or warning macros\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    info_tag = '&lt;p&gt;&lt;ac:structured-macro ac:name=\"info\"&gt;&lt;ac:rich-text-body&gt;&lt;p&gt;'\n    note_tag = info_tag.replace(\"info\", \"note\")\n    warning_tag = info_tag.replace(\"info\", \"warning\")\n    close_tag = \"&lt;/p&gt;&lt;/ac:rich-text-body&gt;&lt;/ac:structured-macro&gt;&lt;/p&gt;\"\n\n    # Custom tags converted into macros\n    html = html.replace(\"&lt;p&gt;~?\", info_tag).replace(\"?~&lt;/p&gt;\", close_tag)\n    html = html.replace(\"&lt;p&gt;~!\", note_tag).replace(\"!~&lt;/p&gt;\", close_tag)\n    html = html.replace(\"&lt;p&gt;~%\", warning_tag).replace(\"%~&lt;/p&gt;\", close_tag)\n\n    # Convert block quotes into macros\n    quotes = re.findall(\"&lt;blockquote&gt;(.*?)&lt;/blockquote&gt;\", html, re.DOTALL)\n    if quotes:\n        for quote in quotes:\n            note = re.search(\"^&lt;.*&gt;Note\", quote.strip(), re.IGNORECASE)\n            warning = re.search(\"^&lt;.*&gt;Warning\", quote.strip(), re.IGNORECASE)\n\n            if note:\n                clean_tag = self.strip_type(quote, \"Note\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", note_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n            elif warning:\n                clean_tag = self.strip_type(quote, \"Warning\")\n                macro_tag = (\n                    clean_tag.replace(\"&lt;p&gt;\", warning_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n            else:\n                macro_tag = (\n                    quote.replace(\"&lt;p&gt;\", info_tag)\n                    .replace(\"&lt;/p&gt;\", close_tag)\n                    .strip()\n                )\n\n            html = html.replace(\"&lt;blockquote&gt;%s&lt;/blockquote&gt;\" % quote, macro_tag)\n\n    # Convert doctoc to toc confluence macro\n    html = self.convert_doctoc(html)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.convert_md_to_conf_html","title":"<code>convert_md_to_conf_html(has_title=False, remove_emojies=False, add_contents=False)</code>","text":"<p>Convert the Markdown file to Confluence HTML</p> <p>Parameters:</p> Name Type Description Default <code>has_title</code> <code>bool</code> <p>Was a title provided via the CLI?</p> <code>False</code> <code>remove_emojies</code> <code>bool</code> <p>Should emojies be removed?</p> <code>False</code> <code>add_contents</code> <code>bool</code> <p>Should a contents section be added to the page</p> <code>False</code> <p>Returns:</p> Type Description <p>A string representing HTML for the Markdown page</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def convert_md_to_conf_html(\n    self,\n    has_title: bool = False,\n    remove_emojies: bool = False,\n    add_contents: bool = False,\n):\n\"\"\"\n    Convert the Markdown file to Confluence HTML\n\n    Args:\n        has_title: Was a title provided via the CLI?\n        remove_emojies: Should emojies be removed?\n        add_contents: Should a contents section be added to the page\n\n    Returns:\n        A string representing HTML for the Markdown page\n    \"\"\"\n    html = self.get_html_from_markdown()\n    if not has_title:\n        html = \"\\n\".join(html.split(\"\\n\")[1:])\n\n    html = self.create_table_of_content(html)\n    html = self.convert_info_macros(html)\n    html = self.convert_comment_block(html)\n    html = self.convert_code_block(html)\n\n    if remove_emojies:\n        html = self.remove_emojies(html)\n\n    if add_contents:\n        html = self.add_contents(html)\n\n    html = self.process_refs(html)\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.create_table_of_content","title":"<code>create_table_of_content(html)</code>","text":"<p>Check for the string '[TOC]' and replaces it the Confluence \"Table of Content\" macro</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def create_table_of_content(self, html: str) -&gt; str:\n\"\"\"\n    Check for the string '[TOC]' and replaces it the\n    Confluence \"Table of Content\" macro\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    html = str.replace(\n        html,\n        r\"&lt;p&gt;[TOC]&lt;/p&gt;\",\n        '&lt;p&gt;&lt;ac:structured-macro ac:name=\"toc\" ac:schema-version=\"1\"/&gt;&lt;/p&gt;',\n    )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.get_html_from_markdown","title":"<code>get_html_from_markdown()</code>","text":"<p>Convert the Markdown file to HTML.  This is a wrapper around the markdown library</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representing HTML for the Markdown page</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def get_html_from_markdown(self) -&gt; str:\n\"\"\"\n    Convert the Markdown file to HTML.  This is a wrapper\n    around the markdown library\n\n    Returns:\n        A string representing HTML for the Markdown page\n    \"\"\"\n    with codecs.open(self.md_file, \"r\", \"utf-8\") as mdfile:\n        markdown_content = mdfile.read()\n        html = markdown.markdown(\n            markdown_content,\n            extensions=[\n                \"tables\",\n                \"fenced_code\",\n                \"footnotes\",\n                \"mdx_truly_sane_lists\",\n            ],\n        )\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.process_refs","title":"<code>process_refs(html)</code>","text":"<p>Process references</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>html string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def process_refs(self, html: str) -&gt; str:\n\"\"\"\n    Process references\n\n    Args:\n        html: html string\n    Returns:\n        modified html string\n    \"\"\"\n    refs = re.findall(r\"\\n(\\[\\^(\\d)\\].*)|&lt;p&gt;(\\[\\^(\\d)\\].*)\", html)\n\n    if refs:\n        for ref in refs:\n            if ref[0]:\n                full_ref = ref[0].replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n                ref_id = ref[1]\n            else:\n                full_ref = ref[2]\n                ref_id = ref[3]\n\n            full_ref = full_ref.replace(\"&lt;/p&gt;\", \"\").replace(\"&lt;p&gt;\", \"\")\n            html = html.replace(full_ref, \"\")\n            href = re.search('href=\"(.*?)\"', full_ref).group(1)\n\n            superscript = '&lt;a id=\"test\" href=\"%s\"&gt;&lt;sup&gt;%s&lt;/sup&gt;&lt;/a&gt;' % (\n                href,\n                ref_id,\n            )\n            html = html.replace(\"[^%s]\" % ref_id, superscript)\n\n    return html\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.remove_emojies","title":"<code>remove_emojies(html)</code>","text":"<p>Remove emojies if there are any</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>string</p> required <p>Returns:     modified html string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def remove_emojies(self, html: str) -&gt; str:\n\"\"\"\n    Remove emojies if there are any\n\n    Args:\n        html: string\n    Returns:\n        modified html string\n    \"\"\"\n    regrex_pattern = re.compile(\n        pattern=\"[\"\n        \"\\U0001F600-\\U0001F64F\"  # emoticons\n        \"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n        \"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n        \"\\U0001F1E0-\\U0001F1FF\"  # flags (iOS)\n        \"]+\",\n        flags=re.UNICODE,\n    )\n    return regrex_pattern.sub(r\"\", html)\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.slug","title":"<code>slug(string, lowercase)</code>","text":"<p>Creates a slug string</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to modify</p> required <code>lowercase</code> <code>bool</code> <p>whether string has to be lowercased</p> required <p>Returns:     slug string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def slug(self, string: str, lowercase: bool) -&gt; str:\n\"\"\"\n    Creates a slug string\n\n    Args:\n        string: string to modify\n        lowercase: whether string has to be lowercased\n    Returns:\n        slug string\n    \"\"\"\n\n    slug_string = string\n    if lowercase:\n        slug_string = string.lower()\n\n    # Remove all html code tags\n    slug_string = re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", slug_string)\n    # Remove html code like '&amp;amp;'\n    slug_string = re.sub(r\"&amp;[a-z]+;\", \"\", slug_string)\n    # Replace all spaces ( ) with dash (-)\n    slug_string = str.replace(slug_string, \" \", \"-\")\n\n    # Remove all special chars, except for dash (-)\n    slug_string = re.sub(r\"[^a-zA-Z0-9-]\", \"\", slug_string)\n\n    return slug_string\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.strip_type","title":"<code>strip_type(tag, tagtype)</code>","text":"<p>Strips Note or Warning tags from html in various formats</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>tag name</p> required <code>tagtype</code> <code>str</code> <p>tag type</p> required <p>Returns:     modified tag</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def strip_type(self, tag: str, tagtype: str) -&gt; str:\n\"\"\"\n    Strips Note or Warning tags from html in various formats\n\n    Args:\n        tag: tag name\n        tagtype: tag type\n    Returns:\n        modified tag\n    \"\"\"\n    tag = re.sub(r\"%s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n    tag = re.sub(r\"%s\\s:\\s\" % tagtype, \"\", tag.strip(), re.IGNORECASE)\n    tag = re.sub(r\"&lt;.*?&gt;%s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;.*?&gt;%s\\s:\\s&lt;.*?&gt;\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s:&lt;.*?&gt;\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    tag = re.sub(r\"&lt;(em|strong)&gt;%s\\s&lt;.*?&gt;:\\s\" % tagtype, \"\", tag, re.IGNORECASE)\n    string_start = re.search(\"&lt;[^&gt;]*&gt;\", tag)\n    tag = self.upper_chars(tag, [string_start.end()])\n    return tag\n</code></pre>"},{"location":"api/converter-reference/#md_to_conf.converter.MarkdownConverter.upper_chars","title":"<code>upper_chars(string, indices)</code>","text":"<p>Make characters uppercase in string</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to modify</p> required <code>indices</code> <code>List[int]</code> <p>character indice to change to uppercase</p> required <p>Returns:     uppercased string</p> Source code in <code>md_to_conf/converter.py</code> <pre><code>def upper_chars(self, string: str, indices: typing.List[int]) -&gt; str:\n\"\"\"\n    Make characters uppercase in string\n\n    Args:\n        string: string to modify\n        indices: character indice to change to uppercase\n    Returns:\n        uppercased string\n    \"\"\"\n    upper_string = \"\".join(\n        c.upper() if i in indices else c for i, c in enumerate(string)\n    )\n    return upper_string\n</code></pre>"},{"location":"api/main-reference/","title":"md_to_conf","text":""},{"location":"api/main-reference/#md_to_conf.main","title":"<code>main()</code>","text":"<p>Main program</p> Source code in <code>md_to_conf/__init__.py</code> <pre><code>def main():\n\"\"\"\n    Main program\n\n    \"\"\"\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - \\\n%(levelname)s - %(funcName)s [%(lineno)d] - \\\n\\t%(message)s\",\n    )\n    LOGGER = logging.getLogger(__name__)\n\n    # ArgumentParser to parse arguments and options\n    PARSER = get_parser()\n\n    ARGS = PARSER.parse_args()\n\n    # Assign global variables\n    try:\n        # Set log level\n        LOGGER.setLevel(getattr(logging, ARGS.loglevel.upper(), None))\n\n        MARKDOWN_FILE = ARGS.markdownFile\n        SPACE_KEY = ARGS.spacekey\n        USERNAME = os.getenv(\"CONFLUENCE_USERNAME\", ARGS.username)\n        API_KEY = os.getenv(\"CONFLUENCE_API_KEY\", ARGS.apikey)\n        ORGNAME = os.getenv(\"CONFLUENCE_ORGNAME\", ARGS.orgname)\n        ANCESTOR = ARGS.ancestor\n        NOSSL = ARGS.nossl\n        DELETE = ARGS.delete\n        SIMULATE = ARGS.simulate\n        VERSION = ARGS.version\n        MARKDOWN_SOURCE = ARGS.markdownsrc\n        LABELS = ARGS.labels\n        PROPERTIES = dict(ARGS.properties)\n        ATTACHMENTS = ARGS.attachment\n        CONTENTS = ARGS.contents\n        TITLE = ARGS.title\n        REMOVE_EMOJIES = ARGS.remove_emojies\n\n        validate_args(USERNAME, API_KEY, MARKDOWN_FILE, ORGNAME)\n\n    except Exception as err:\n        LOGGER.error(\"\\n\\nException caught:\\n%s \", err)\n        LOGGER.error(\"\\nFailed to process command line arguments. Exiting.\")\n        sys.exit(1)\n\n    LOGGER.info(\"\\t----------------------------------\")\n    LOGGER.info(\"\\tMarkdown to Confluence Upload Tool\")\n    LOGGER.info(\"\\t----------------------------------\")\n\n    LOGGER.info(\"Markdown file:\\t%s\", MARKDOWN_FILE)\n    LOGGER.info(\"Space Key:\\t%s\", SPACE_KEY)\n\n    confluence_converter: ConfluenceConverter = ConfluenceConverter(\n        MARKDOWN_FILE,\n        MARKDOWN_SOURCE,\n        TITLE,\n        ORGNAME,\n        not NOSSL,\n        USERNAME,\n        SPACE_KEY,\n        API_KEY,\n        ANCESTOR,\n        VERSION,\n    )\n\n    confluence_converter.convert(\n        SIMULATE, DELETE, REMOVE_EMOJIES, CONTENTS, LABELS, PROPERTIES, ATTACHMENTS\n    )\n</code></pre>"}]}